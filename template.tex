\documentclass[debug,practica]{lcc}

\codigo{R-987}
\materia{Tipografía en \LaTeX}
\num{1}
\titulo{Práctica de Ejemplo}

% Para dejar comentarios
% \def\alan{\comm{red}{Alan Turing}}

\begin{document}

\maketitle

Este es un ejemplo de una práctica. Dentro hay algunos if que pueden
encenderse para mostrar las soluciones de los ejercicios.
\guido{Por ejemplo, este es un comentario}

\begin{ejercicio}
    El siguiente código computa una aproximación a
    $\frac{1}{\sqrt{x}}$. Explique su funcionamiento.
    \begin{C}
float Q_rsqrt(float number)
{
    long i;
    float x2, y;
    const float threehalfs = 1.5F;

    x2 = number * 0.5F;
    y  = number;
    i  = * (long *) &y;                   // evil floating point bit level hacking
    i  = 0x5f3759df - (i >> 1);           // what the fuck?
    y  = * (float *) &i;
    y  = y * (threehalfs - (x2 * y * y)); // 1st iteration
    y  = y * (threehalfs - (x2 * y * y)); // 2nd iteration, this can be removed

    return y;
}
    \end{C}
    \begin{solucion}
        Ver: \url{https://www.youtube.com/watch?v=p8u_k2LIZyo}
        \begin{C}
/* Código dentro de solución */
        \end{C}
    \end{solucion}
\end{ejercicio}

\begin{ejercicioOff}[(Filósofos Comensales, Dijkstra)]
    Esto es un ejercicio oculto. Cambiar \texttt{ejercicioOff} a
    \texttt{ejercicio} para mostrarlo.
    \begin{solucion}
        Esta es la solución del ejercicio oculto.
    \end{solucion}
\end{ejercicioOff}

\begin{ejercicio}
    Esto es un ejercicio.
    \begin{solucion}
        Acá está la solución.
    \end{solucion}
    \begin{solucion}[variante 2]
        Acá hay otra solucion.
    \end{solucion}
\end{ejercicio}

\begin{ejercicio}[(difícil)]
    Este es un ejercicio con un tag opcional.
\end{ejercicio}

\begin{ejercicio}[\unskip*]
    Este es un ejercicio con una estrella.
\end{ejercicio}

\begin{ejercicio}
    ¿Es la siguiente definición de \hask{fibs} una estructura cíclica?
    \begin{Hask}
fibs :: [Integer]
fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
    \end{Hask}
\end{ejercicio}

\begin{ejercicio}
    Este ejercicio tiene un fragmento de código C.
    \begin{C}
int main()
{
    return 0;
}
    \end{C}
    Y tambien algo de codigo C inline: \cc{return (v&(v-1)) == 0;}.
\end{ejercicio}

\begin{ejercicio}
    También puede incluirse código Bash.
    \begin{Bash}
a=0
while [ $a -le 100 ]; do
    echo $a
    a=$((a+1))
done
    \end{Bash}
    O también inline: \bash{:()\{ :|:& \};:}.
\end{ejercicio}

\begin{ejercicio}
    Acá hay Python:
    \begin{Py}
def ack(m, n):
    if m == 0:
        return n+1
    elif n == 0:
        return ack (m-1, 1)
    else:
        return ack (m-1, ack (m, n-1))
    \end{Py}
\end{ejercicio}

\section{Una Sección}

Acá vienen más ejercicios:

\begin{ejercicio}
    El siguiente código Erlang implementa la función factorial.
    Explique cómo, dado que no hay ninguna función recursiva a la vista.
    \begin{Erl}
y(F) ->
	G = (fun (X) -> F (fun (Y) -> (X(X))(Y) end) end),
	G(G).

fact(N) ->
	F0 = fun (F) -> (fun (X) -> if X == 0 -> 1; true -> X * F (X-1) end end) end,
	(y(F0))(N).
    \end{Erl}
\end{ejercicio}

\begin{ejercicio}
    Convierta la siguiente función a un bucle, sin llamadas
    recursivas.
    Pista: defina variables enteras \cc{m} y \cc{b} y
    mantenga invariante de $J(n) = m \times J(n_0) + b$ donde
    $n_0$ es el valor inicial de la llamada.

    \begin{C}
int J(int n) {
    if (n == 1)
        return 1;
    if (n&1)
        return 2*J(n/2) + 1;
    return 2*J(n/2) - 1;
}
    \end{C}
    \begin{solucion}
        Ver el uso de modo math dentro del código (con opción \texttt{mathescape}).
        \begin{C}[mathescape]
int J$^{loop}$(int n) {
    /* Inv: $J(n_0) = m \times J(n) + b$ */
    int m=1, b=0;
    while (n != 1) {
        if (n&1) {
            /* Del invariante y de la definición original de $J$,
             * tenemos:
             *  $\begin{array}{rcl}
                       J(n_0) &=& m \times J(n) + b \\
                       J(n)   &=& 2 \times J\lfloor n/2 \rfloor + 1
                \end{array}$
             * A partir de ahí podemos sacar unas cuentas y concluir:
             *    $J(n_0) = 2 \times m \times J\lfloor n/2 \rfloor + (b+m)$,
             * justificando este paso */
            b += m; m *= 2;
        } else {
            b -= m; m *= 2;
        }
        n = n/2;
    }
    return m + b;
    /* Dado que ahora $n=1$, por el invariante, esto es $J(n_0)$ */
}
        \end{C}
    \end{solucion}
\end{ejercicio}

\end{document}
