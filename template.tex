\documentclass[debug,practica]{lcc}

\codigo{R-987}
\materia{Tipografía en \LaTeX}
\num{1}
\titulo{Práctica de Ejemplo}

% Para dejar comentarios
% \def\alan{\comm{red}{Alan Turing}}

\begin{document}

\maketitle

Este es un ejemplo de una práctica. Dentro hay algunos if que pueden
encenderse para mostrar las soluciones de los ejercicios.
\guido{Por ejemplo, este es un comentario}

\begin{ejercicio}
    El siguiente código computa una aproximación a
    $\frac{1}{\sqrt{x}}$. Explique su funcionamiento.
    \begin{C}
float Q_rsqrt(float number)
{
    long i;
    float x2, y;
    const float threehalfs = 1.5F;

    x2 = number * 0.5F;
    y  = number;
    i  = * (long *) &y;                   // evil floating point bit level hacking
    i  = 0x5f3759df - (i >> 1);           // what the fuck?
    y  = * (float *) &i;
    y  = y * (threehalfs - (x2 * y * y)); // 1st iteration
    y  = y * (threehalfs - (x2 * y * y)); // 2nd iteration, this can be removed

    return y;
}
    \end{C}
    \begin{solucion}
        Ver: \url{https://www.youtube.com/watch?v=p8u_k2LIZyo}
        \begin{C}
/* Código dentro de solución */
        \end{C}
    \end{solucion}
\end{ejercicio}

\begin{ejercicioOff}[(Filósofos Comensales, Dijkstra)]
    Esto es un ejercicio oculto. Cambiar \texttt{ejercicioOff} a
    \texttt{ejercicio} para mostrarlo.
    \begin{solucion}
        Esta es la solución del ejercicio oculto.
    \end{solucion}
\end{ejercicioOff}

\begin{ejercicio}
    Esto es un ejercicio.
    \begin{solucion}
        Acá está la solución.
    \end{solucion}
    \begin{solucion}[variante 2]
        Acá hay otra solucion.
    \end{solucion}
\end{ejercicio}

\begin{ejercicio}[(difícil)]
    Este es un ejercicio con un tag opcional.
\end{ejercicio}

\begin{ejercicio}[\unskip*]
    Este es un ejercicio con una estrella.
\end{ejercicio}

\begin{ejercicio}
    ¿Es la siguiente definición de \hask{fibs} una estructura cíclica?
    \begin{Hask}
fibs :: [Integer]
fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
    \end{Hask}
\end{ejercicio}

\begin{ejercicio}
    Este ejercicio tiene un fragmento de código C.
    \begin{C}
int main()
{
    return 0;
}
    \end{C}
    Y tambien algo de codigo C inline: \cc{return (v&(v-1)) == 0;}.
\end{ejercicio}

\begin{ejercicio}
    También puede incluirse código Bash.
    \begin{Bash}
a=0
while [ $a -le 100 ]; do
    echo $a
    a=$((a+1))
done
    \end{Bash}
    O también inline: \bash{:()\{ :|:& \};:}.
\end{ejercicio}

\begin{ejercicio}
    Acá hay Python:
    \begin{Py}
def ack(m, n):
    if m == 0:
        return n+1
    elif n == 0:
        return ack (m-1, 1)
    else:
        return ack (m-1, ack (m, n-1))
    \end{Py}
\end{ejercicio}

\section{Una Sección}

Acá vienen más ejercicios:

\begin{ejercicio}
    El siguiente código Erlang implementa la función factorial.
    Explique cómo, dado que no hay ninguna función recursiva a la vista.
    \begin{Erl}
y(F) ->
	G = (fun (X) -> F (fun (Y) -> (X(X))(Y) end) end),
	G(G).

fact(N) ->
	F0 = fun (F) -> (fun (X) -> if X == 0 -> 1; true -> X * F (X-1) end end) end,
	(y(F0))(N).
    \end{Erl}
\end{ejercicio}

\end{document}
